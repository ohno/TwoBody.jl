var documenterSearchIndex = {"docs":
[{"location":"FDM/#Finite-Difference-Method","page":"Finite Difference Method","title":"Finite Difference Method","text":"","category":"section"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"This method solve the eigenvalue problem for the Hamiltonian discretized as a sparse matrix with finite difference approximation,","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"pmbH pmbpsi = E pmbpsi","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"The eigenvalue E is an approximation of the exact energy and the eigenvector pmbpsi is a vector of the approximated values of the exact wavefunction psi(r) on points of the grid,","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"pmbpsi\n=\nleft(beginarrayc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  vdots \nendarrayright)","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"A uniform grid spacing is used, r_i+1 = r_i + Delta r. See the API reference for the expression of the matrix pmbH.","category":"page"},{"location":"FDM/#Usage","page":"Finite Difference Method","title":"Usage","text":"","category":"section"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"Run the following code before each use.","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"using TwoBody","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"Define the Hamiltoninan. This is an example for the non-relativistic Hamiltonian of hydrogen atom in atomic units:","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"hatH = \n- frac12 nabla^2\n- frac1r","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"H = Hamiltonian(\n  NonRelativisticKinetic(ℏ = 1 , m = 1),\n  CoulombPotential(coefficient = -1),\n)\nnothing # hide","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"Set the calculation options.","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"FDM = FiniteDifferenceMethod(\n  Δr = 0.1,\n  rₘₐₓ = 50.0,\n  l = 0,\n  direction = :c,\n  solver = :LinearAlgebra,\n)\nnothing # hide","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"Solve the eigenvalue problem. You should find reasonable approximations to the exact eigenvalues:","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"beginaligned\n  E_n=1 = -05\n  E_n=2 = -0125\n  E_n=3 = -005555cdots\n  E_n=4 = -003125\nendaligned","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"By default the eigenvalues and the expectation values are displayed.","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"solve(H, FDM)","category":"page"},{"location":"FDM/#Example-of-Hydrogen-Atom","page":"Finite Difference Method","title":"Example of Hydrogen Atom","text":"","category":"section"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"Analytical solutions are implemented in Antique.jl.","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"# solve\nusing TwoBody\nH = Hamiltonian(NonRelativisticKinetic(1,1), CoulombPotential(-1))\nFDM = FiniteDifferenceMethod()\nres = solve(H, FDM, info=0, nₘₐₓ=4)\n\n# benchmark\nimport Antique\nHA = Antique.HydrogenAtom(Z=1, Eₕ=1.0, a₀=1.0, mₑ=1.0, ℏ=1.0)\n\n# energy\nusing Printf\nprintln(\"Total Energy Eₙ\")\nprintln(\"------------------------------\")\nprintln(\" n     numerical    analytical\")\nprintln(\"------------------------------\")\nfor n in 1:4\n  @printf(\"%2d  %+.9f  %+.9f\\n\", n, res.E[n], Antique.E(HA,n=n))\nend\n\n# wave function\nusing CairoMakie\nfig = Figure(\n  size = (840,600),\n  fontsize = 11.5,\n  backgroundcolor = :transparent\n)\nfor n in 1:4\n  axis = Axis(\n    fig[div(n-1,2)+1,rem(n-1,2)+1],\n    xlabel = L\"$r~/~a_0$\",\n    ylabel = L\"$4\\pi r^2|\\psi(r)|^2~ /~{a_0}^{-1}$\",\n    xlabelsize = 16.5,\n    ylabelsize = 16.5,\n    limits=(\n      0, [5, 15, 30, 50][n],\n      0, [0.6, 0.2, 0.11, 0.07][n],\n    )\n  )\n  X = res.method.R\n  Y = 4π * X .^2 .* res.ψ[:,n] .^ 2\n  scatter!(axis, X, Y, label=\"TwoBody.jl\", markersize=6)\n  lines!(axis, 0..50, r -> 4π * r^2 * abs(Antique.ψ(HA,r,0,0,n=n))^2, label=\"Antique.jl\", color=:black)\n  axislegend(axis, \"n = $n\", position=:rt, framevisible=false)\nend\nsave(\"assets/FDM_HA.svg\", fig) # hide\n; # hide","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"(Image: )","category":"page"},{"location":"FDM/#Example-of-Spherical-Oscillator","page":"Finite Difference Method","title":"Example of Spherical Oscillator","text":"","category":"section"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"Analytical solutions are implemented in spherical oscillator.","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"# solve\nusing TwoBody\nH = Hamiltonian(NonRelativisticKinetic(1,1), PowerLawPotential(coefficient=1/2,exponent=2))\nFDM = FiniteDifferenceMethod(rₘₐₓ=10.0)\nres = solve(H, FDM, info=0, nₘₐₓ=4)\n\n# benchmark\nimport Antique\nSO = Antique.SphericalOscillator(k=1.0, μ=1.0, ℏ=1.0)\n\n# energy\nusing Printf\nprintln(\"Total Energy Eₙ\")\nprintln(\"------------------------------\")\nprintln(\" n     numerical    analytical\")\nprintln(\"------------------------------\")\nfor n in 1:4\n  @printf(\"%2d  %+.9f  %+.9f\\n\", n-1, res.E[n], Antique.E(SO,n=n-1))\nend\n\n# wave function\nusing CairoMakie\nfig = Figure(\n  size = (840,600),\n  fontsize = 11.5,\n  backgroundcolor = :transparent\n)\nfor n in 1:4\n  axis = Axis(\n    fig[div(n-1,2)+1,rem(n-1,2)+1],\n    xlabel = L\"$r~/~a_0$\",\n    ylabel = L\"$4\\pi r^2|\\psi(r)|^2~ /~{a_0}^{-1}$\",\n    xlabelsize = 16.5,\n    ylabelsize = 16.5,\n    limits=(\n      0, [4.5, 5.0, 5.5, 6.0][n],\n      0, [0.90, 0.75, 0.70, 0.65][n],\n    )\n  )\n  X = res.method.R\n  Y = 4π * X .^2 .* res.ψ[:,n] .^ 2\n  scatter!(axis, X, Y, label=\"TwoBody.jl\", markersize=6)\n  lines!(axis, 0..50, r -> 4π * r^2 * abs(Antique.ψ(SO,r,0,0,n=n-1))^2, label=\"Antique.jl\", color=:black)\n  axislegend(axis, \"n = $(n-1)\", position=:rt, framevisible=false)\nend\nfig\nsave(\"assets/FDM_SO.svg\", fig) # hide\n; # hide","category":"page"},{"location":"FDM/","page":"Finite Difference Method","title":"Finite Difference Method","text":"(Image: )","category":"page"},{"location":"FDM/#API-reference","page":"Finite Difference Method","title":"API reference","text":"","category":"section"},{"location":"FDM/#TwoBody.FiniteDifferenceMethod-FDM","page":"Finite Difference Method","title":"TwoBody.FiniteDifferenceMethod","text":"FiniteDifferenceMethod(Δr=0.1, rₘₐₓ=50.0, R=Δr:Δr:rₘₐₓ, l=0, direction=:c, solver=:LinearAlgebra)\n\nArguments Default Description\nΔr::Real 0.1 Radial grid spacing. A uniform grid spacing is used, r_i+1 = r_i + Delta r.\nrₘₐₓ::Real 50.0 The maximum value of the radial grid. This value is not directly used in the calculation, but it is used to determine the R.\nR::StepRangeLen Δr:Δr:rₘₐₓ Radial grid. The origin must be excluded from the grid to avoid divergence of the Coulomb potential and the centrifugal potential at the origin.\nl::Int 0 Angular momentum quantum number. This is a positive integer, 0 leq l.\ndirection::Symbol :c The direction of the finite difference, :c for central, :f for forward, :b for backward.\nsolver::Symbol :LinearAlgebra The solver for eigenvalue problem, :LinearAlgebra or :ArnoldiMethod.\n\n\n\n\n\n","category":"type"},{"location":"FDM/#TwoBody.solve-Tuple{Hamiltonian, FiniteDifferenceMethod}-FDM","page":"Finite Difference Method","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, method::FiniteDifferenceMethod; perturbation=Hamiltonian(), info=4, nₘₐₓ=4)\n\nThis method solve the eigenvalue problem for the Hamiltonian discretized as a sparse matrix with finite difference approximation,\n\npmbH pmbpsi = E pmbpsi\n\nThe eigenvalue E is an approximation of the exact energy and the eigenvector pmbpsi is a vector of the approximated values of the exact wavefunction psi(r) on points of the grid,\n\npmbpsi\n=\nleft(beginarrayc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  vdots \nendarrayright)\n\n\n\n\n\n","category":"method"},{"location":"FDM/#TwoBody.matrix-Tuple{Hamiltonian, FiniteDifferenceMethod}-FDM","page":"Finite Difference Method","title":"TwoBody.matrix","text":"matrix(o::Hamiltonian, method::FiniteDifferenceMethod)\n\nThe matrix for the Hamiltonian is a sum of matrices for each term,\n\npmbH = sum_i pmbO_i\n\n\n\n\n\n","category":"method"},{"location":"FDM/#TwoBody.matrix-Tuple{RestEnergy, FiniteDifferenceMethod}-FDM","page":"Finite Difference Method","title":"TwoBody.matrix","text":"matrix(o::RestEnergy, method::FiniteDifferenceMethod)\n\nThe matrix for the rest energy mc^2 is a diagonal matrix,\n\nmc^2\nleft(beginarrayccccccc\n  1  0  0  ldots \n  0  1  0  ldots \n  0  0  1  ldots \n  vdots  vdots  vdots  ddots \nendarrayright)\n\n\n\n\n\n","category":"method"},{"location":"FDM/#TwoBody.matrix-Tuple{NonRelativisticKinetic, FiniteDifferenceMethod}-FDM","page":"Finite Difference Method","title":"TwoBody.matrix","text":"matrix(o::NonRelativisticKinetic, method::FiniteDifferenceMethod)\n\nWe use the shorthand notation psi(r) = fracmathrmdpsimathrmdr(r) and psi(r) = fracmathrmd^2psimathrmdr^2(r). For the uniform grid spacing (r_i+1 = r_i + Delta r), the finite difference for the first derivative,\n\nfracmathrmdpsimathrmdr(r) = fracpsi(r+Delta r) - psi(r-Delta r)2Delta r + O(Delta r^2)\n\nis written as\n\nleft(beginarrayccccc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  psi(r_4) \n  vdots\nendarrayright)\nsimeq\nfrac12Delta r\nleft(beginarrayccccc\n   0   1   0   0 ldots \n  -1   0   1   0 ldots \n   0  -1   0   1 ldots \n   0   0  -1   0 ldots \n  vdots  vdots  vdots  vdots  ddots \nendarrayright)\nleft(beginarrayccccccc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  psi(r_4) \n  vdots\nendarrayright)\n\nand the finite difference for the second derivative,\n\nfracmathrmd^2mathrmdr^2(r) = fracpsi(r+Delta r) - 2f(r) + psi(r-Delta r)Delta r^2 + O(Delta r^2)\n\nis written as\n\nleft(beginarrayccccc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  psi(r_4) \n  vdots\nendarrayright)\nsimeq\nfrac1Delta r^2\nleft(beginarrayccccccc\n  -2   1   0   0  ldots \n   1  -2   1   0  ldots \n   0   1  -2   1  ldots \n   0   0   1  -2  ldots \n  vdots  vdots  vdots  vdots  ddots \nendarrayright)\nleft(beginarrayccccccc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  psi(r_4) \n  vdots\nendarrayright)\n\nSimilarly, the matrix for the kinetic energy,\n\nhatT\n=\n-frachbar^22mu\nleft\n      fracpartial^2partial r^2\n    + frac2r fracpartialpartial r\n    - fracl(l+1)r^2\nright\n\nis written as\n\npmbT\n= - frachbar^22mu\n  left\n    frac1Delta r^2\n    left(beginarrayccccccc\n      -2  1  0  ldots \n      1  -2  1  ldots \n      0  1  -2  ldots \n      vdots  vdots  vdots  ddots \n    endarrayright)\n    +\n    left(beginarrayccccccc\n       2r_1  0  0  ldots \n       0  2r_2  0  ldots \n       0  0  2r_3  ldots \n      vdots  vdots  vdots  ddots \n    endarrayright)\n    frac1Delta r\n    left(beginarrayccccccc\n       0   1   0  ldots \n      -1   0   1  ldots \n       0  -1   0  ldots \n      vdots  vdots  vdots  ddots \n    endarrayright)\n    - l(l+1)\n    left(beginarrayccccccc\n       1r_1^2  0  0  ldots \n       0  1r_2^2  0  ldots \n       0  0  1r_3^2  ldots \n      vdots  vdots  vdots  ddots \n    endarrayright)\n  right\n\n\n\n\n\n","category":"method"},{"location":"FDM/#TwoBody.matrix-Tuple{TwoBody.PotentialTerm, FiniteDifferenceMethod}-FDM","page":"Finite Difference Method","title":"TwoBody.matrix","text":"matrix(o::PotentialTerm, method::FiniteDifferenceMethod)\n\nThe matrix for the potential energy V(r) is a diagonal matrix,\n\npmbV = \nleft(beginarrayccccccc\n  V(r_1)  0  0  ldots \n  0  V(r_2)  0  ldots \n  0  0  V(r_3)  ldots \n  vdots  vdots  vdots  ddots \nendarrayright)\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#Rayleigh–Ritz-Method","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"","category":"section"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"This method is one of the variational method. It solves the generalized eigenvalue problem,","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"pmbH pmbc = E pmbS pmbc","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"The Hamiltonian matrix is defined as H_ij = langle phi_i  hatH  phi_j rangle and the overlap matrix is defined as S_ij = langle phi_i  phi_j rangle. The eigenvector pmbc is the column of the optimal coefficients c_i for the linear combination,","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"psi(r) = sum_i c_i phi_i(r)","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"to minmize the expectation value of the energy,","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"E = fraclanglepsihatHpsiranglelanglepsipsirangle","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"Note that the nonlinear parameters (e.g., exponents of the Gaussian basis functions) are not optimized. The expectation by trial wavefunction is the upper bound for the exact energy.","category":"page"},{"location":"Rayleigh–Ritz/#Usage","page":"Rayleigh–Ritz Method","title":"Usage","text":"","category":"section"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"Run the following code before each use.","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"using TwoBody","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"Define the Hamiltoninan. This is an example for the non-relativistic Hamiltonian of hydrogen atom in atomic units:","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"hatH = \n- frac12 nabla^2\n- frac1r","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"H = Hamiltonian(\n  NonRelativisticKinetic(ℏ = 1 , m = 1),\n  CoulombPotential(coefficient = -1),\n)\nnothing # hide","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"Define the basis set:","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"beginaligned\n  phi_1(r) = exp(-1300773 r^2) \n  phi_2(r) = exp(-1962079 r^2) \n  phi_3(r) = exp(-0444529 r^2) \n  phi_4(r) = exp(-01219492 r^2)\nendaligned","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"BS = BasisSet(\n  SimpleGaussianBasis(13.00773),\n  SimpleGaussianBasis(1.962079),\n  SimpleGaussianBasis(0.444529),\n  SimpleGaussianBasis(0.1219492),\n)\nnothing # hide","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"Solve the eigenvalue problem. You should find","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"E_n=1 = -0499278E_mathrmh","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"which is amazingly good for only four basis functions according to Thijssen(2007). The exact ground-state energy is -05E_mathrmh.","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"solve(H, BS)","category":"page"},{"location":"Rayleigh–Ritz/#Example-of-Hydrogen-Atom","page":"Rayleigh–Ritz Method","title":"Example of Hydrogen Atom","text":"","category":"section"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"Analytical solutions are implemented in Antique.jl.","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"# solve\nusing TwoBody\nH = Hamiltonian(NonRelativisticKinetic(1,1), CoulombPotential(-1))\nBS = GeometricBasisSet(SimpleGaussianBasis, 0.1, 80.0, 20)\nres = solve(H, BS, info=0)\n\n# benchmark\nimport Antique\nHA = Antique.HydrogenAtom(Z=1, Eₕ=1.0, a₀=1.0, mₑ=1.0, ℏ=1.0)\n\n# energy\nusing Printf\nprintln(\"Total Energy Eₙ\")\nprintln(\"------------------------------\")\nprintln(\" n     numerical    analytical\")\nprintln(\"------------------------------\")\nfor n in 1:4\n  @printf(\"%2d  %+.9f  %+.9f\\n\", n, res.E[n], Antique.E(HA,n=n))\nend\n\n# wave function\nusing CairoMakie\nfig = Figure(\n  size = (840,600),\n  fontsize = 11.5,\n  backgroundcolor = :transparent\n)\nfor n in 1:4\n  axis = Axis(\n    fig[div(n-1,2)+1,rem(n-1,2)+1],\n    xlabel = L\"$r~/~a_0$\",\n    ylabel = L\"$4\\pi r^2|\\psi(r)|^2~ /~{a_0}^{-1}$\",\n    xlabelsize = 16.5,\n    ylabelsize = 16.5,\n    limits=(\n      0, [5, 15, 30, 50][n],\n      0, [0.6, 0.2, 0.11, 0.07][n],\n    )\n  )\n  lines!(axis, 0..50, r -> 4π * r^2 * abs(res.ψ[n](r))^2, label=\"TwoBody.jl\")\n  lines!(axis, 0..50, r -> 4π * r^2 * abs(Antique.ψ(HA,r,0,0,n=n))^2, label=\"Antique.jl\", color=:black, linestyle=:dash)\n  axislegend(axis, \"n = $n\", position=:rt, framevisible=false)\nend\nfig\nsave(\"assets/RR_HA.svg\", fig) # hide\n; # hide","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"(Image: )","category":"page"},{"location":"Rayleigh–Ritz/#Example-of-Spherical-Oscillator","page":"Rayleigh–Ritz Method","title":"Example of Spherical Oscillator","text":"","category":"section"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"Analytical solutions are implemented in spherical oscillator.","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"# solve\nusing TwoBody\nH = Hamiltonian(NonRelativisticKinetic(1,1), PowerLawPotential(coefficient=1/2,exponent=2))\nBS = GeometricBasisSet(SimpleGaussianBasis, 1.0, 10.0, 20)\nres = solve(H, BS, info=0)\n\n# benchmark\nimport Antique\nSO = Antique.SphericalOscillator(k=1.0, μ=1.0, ℏ=1.0)\n\n# energy\nusing Printf\nprintln(\"Total Energy Eₙ\")\nprintln(\"------------------------------\")\nprintln(\" n     numerical    analytical\")\nprintln(\"------------------------------\")\nfor n in 1:4\n  @printf(\"%2d  %+.9f  %+.9f\\n\", n-1, res.E[n], Antique.E(SO,n=n-1))\nend\n\n# wave function\nusing CairoMakie\nfig = Figure(\n  size = (840,600),\n  fontsize = 11.5,\n  backgroundcolor = :transparent\n)\nfor n in 1:4\n  axis = Axis(\n    fig[div(n-1,2)+1,rem(n-1,2)+1],\n    xlabel = L\"$r~/~a_0$\",\n    ylabel = L\"$4\\pi r^2|\\psi(r)|^2~ /~{a_0}^{-1}$\",\n    xlabelsize = 16.5,\n    ylabelsize = 16.5,\n    limits=(\n      0, [4.5, 5.0, 5.5, 6.0][n],\n      0, [0.90, 0.75, 0.70, 0.65][n],\n    )\n  )\n  lines!(axis, 0..50, r -> 4π * r^2 * abs(res.ψ[n](r))^2, label=\"TwoBody.jl\")\n  lines!(axis, 0..50, r -> 4π * r^2 * abs(Antique.ψ(SO,r,0,0,n=n-1))^2, label=\"Antique.jl\", color=:black, linestyle=:dash)\n  axislegend(axis, \"n = $(n-1)\", position=:rt, framevisible=false)\nend\nfig\nsave(\"assets/RR_SO.svg\", fig) # hide\n; # hide","category":"page"},{"location":"Rayleigh–Ritz/","page":"Rayleigh–Ritz Method","title":"Rayleigh–Ritz Method","text":"(Image: )","category":"page"},{"location":"Rayleigh–Ritz/#API-reference","page":"Rayleigh–Ritz Method","title":"API reference","text":"","category":"section"},{"location":"Rayleigh–Ritz/#Solver","page":"Rayleigh–Ritz Method","title":"Solver","text":"","category":"section"},{"location":"Rayleigh–Ritz/#TwoBody.solve-Tuple{Hamiltonian, BasisSet}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, basisset::BasisSet)\n\nThis function returns the eigenvalues E  and eigenvectors pmbc for\n\npmbH pmbc = E pmbS pmbc\n\nThe Hamiltonian matrix is defined as H_ij = langle phi_i  hatH  phi_j rangle. The overlap matrix is defined as S_ij = langle phi_i  phi_j rangle.\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.solve-Tuple{Hamiltonian, Basis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, basis::Basis; perturbation=Hamiltonian(), info=4)\n\nThis a solver for 1-basis calculations. This function returns solve(hamiltonian, BasisSet(basis); perturbation=perturbation, info=info).\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.solve-Tuple{Hamiltonian, GeometricBasisSet}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, basisset::GeometricBasisSet; perturbation=Hamiltonian(), info=4)\n\nThis function is a wrapper for solve(hamiltonian::Hamiltonian, basisset::BasisSet, ...).\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.optimize-Tuple{Hamiltonian, BasisSet}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.optimize","text":"function optimize(hamiltonian::Hamiltonian, basisset::BasisSet; perturbation=Hamiltonian(), info=4, progress=true, optimizer=Optim.NelderMead(), options...)\n\nThis function minimizes the energy by changing the exponents of the basis functions using Optim.jl.\n\nfracpartial Epartial a_i = 0\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.optimize-Tuple{Hamiltonian, Basis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.optimize","text":"optimize(hamiltonian::Hamiltonian, basis::Basis; perturbation=Hamiltonian(), info=4, optimizer=Optim.NelderMead())\n\nThis a optimizer for 1-basis calculations. This function returns optimize(hamiltonian, BasisSet(basis); perturbation=perturbation, info=info, progress=progress, optimizer=optimizer, options...).\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.optimize-Tuple{Hamiltonian, GeometricBasisSet}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.optimize","text":"optimize(hamiltonian::Hamiltonian, basisset::GeometricBasisSet; perturbation=Hamiltonian(), info=4, optimizer=Optim.NelderMead())\n\nThis function minimizes the energy by optimizing r_1 and r_n using Optim.jl.\n\nfracpartial Epartial r_1 = fracpartial Epartial r_n = 0\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#Basis-Set","page":"Rayleigh–Ritz Method","title":"Basis Set","text":"","category":"section"},{"location":"Rayleigh–Ritz/#TwoBody.BasisSet-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.BasisSet","text":"BasisSet(basis1, basis2, ...)\n\n phi_1 phi_2 phi_3 cdots  \n\nThe basis set is the input for Rayleigh–Ritz method. You can define the basis set like this:\n\nbeginaligned\n  phi_1(r) = exp(-1300773 r^2) \n  phi_2(r) = exp(-1962079 r^2) \n  phi_3(r) = exp(-0444529 r^2) \n  phi_4(r) = exp(-01219492 r^2)\nendaligned\n\nBS = BasisSet(\n  SimpleGaussianBasis(13.00773),\n  SimpleGaussianBasis(1.962079),\n  SimpleGaussianBasis(0.444529),\n  SimpleGaussianBasis(0.1219492),\n)\n\n\n\n\n\n","category":"type"},{"location":"Rayleigh–Ritz/#TwoBody.GeometricBasisSet-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.GeometricBasisSet","text":"GeometricBasisSet(basistype, r₁, rₙ, n; nₘᵢₙ=1, nₘₐₓ=n)\n\nThis is a basis set with exponentials generated by geometric().\n\n\n\n\n\n","category":"type"},{"location":"Rayleigh–Ritz/#TwoBody.geometric-Tuple{Any, Any, Int64}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.geometric","text":"Exponents of Gaussian basis functions are given by geometric progression:\n\nbeginaligned\n   v_i = frac1r_i^2 \n   r_i = r_1 a^i-1\nendaligned\n\nThis function return array of nu_i:\n\n(r_1 r_n n n_mathrmmax) mapsto (nu_1 nu_2 cdots nu_n-1 nu_n nu_n+1 cdots nu_n_mathrmmax)\n\nUsually n = n_mathrmmax. Set nn_mathrmmax if you want to extend the geometric progression.\n\nExamples:\n\njulia> ν = TwoBody.geometric(0.1, 10.0, 5)\n5-element Vector{Float64}:\n 100.0\n  10.0\n   0.9999999999999997\n   0.09999999999999996\n   0.009999999999999995\n\njulia> ν = TwoBody.geometric(0.1, 10.0, 5, nₘₐₓ = 10)\n10-element Vector{Float64}:\n 100.0\n  10.0\n   0.9999999999999997\n   0.09999999999999996\n   0.009999999999999995\n   0.0009999999999999994\n   9.999999999999994e-5\n   9.999999999999992e-6\n   9.999999999999991e-7\n   9.999999999999988e-8\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#Basis-Functions","page":"Rayleigh–Ritz Method","title":"Basis Functions","text":"","category":"section"},{"location":"Rayleigh–Ritz/#TwoBody.SimpleGaussianBasis-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.SimpleGaussianBasis","text":"SimpleGaussianBasis(a=1)\n\nnote: Note\nThis basis is not normalized and only for s-wave.\n\nPosition-Space\n\nphi_i(pmbr) = exp(-a_i r^2)\n\nMomentum-Space\n\nphi_i(pmbk)  = frac1(2a_i)^frac32 exp(-k^24a_i)\n\nProof (Fourier Transform)\n\nbeginaligned\n  phi_n(pmbk)\n  = frac1sqrt2 pi^3\n     int\n     phi_n(pmbr)\n     mathrme^mathrmi pmbk cdot pmbr\n     mathrmdpmbr \n  = frac1sqrt2 pi^3\n     int\n     phi_n(pmbr)\n     mathrme^mathrmi pmbk cdot pmbr \n     r^2 sin (theta)\n     mathrmdr\n     mathrmdtheta\n     mathrmd varphi \n  = frac1sqrt2 pi^3\n     iiint\n     mathrme^-alpha_i r^2\n     sqrt4pi Y_00(hatpmbr)\n     left\n       4 pi sum_l=0^infty sum_m=-l^l\n       mathrmi^l\n       j_l(pr)\n       Y_lm(hatpmbk)\n       Y_lm^*(hatpmbr)\n     right\n     r^2 sintheta\n     mathrmd r\n     mathrmd theta\n     mathrmd varphi \n  = frac1sqrt2 pi^3\n     4 pi sqrt4pi sum_l=0^infty sum_m=-l^l left\n     mathrmi^l\n     Y_lm(hatpmbk)\n     int_0^2 pi \n     int_0^pi\n       Y_00(hatpmbr)\n       Y_lm^*(hatpmbr)\n       sin (theta)\n     mathrmd theta\n     mathrmd varphi\n     int_0^infty\n       j_l(pr)\n       mathrme^-alpha_i r^2\n       r^2\n       mathrmdr\n     right\n  =  frac1sqrt2 pi^3\n     4 pi sqrt4pi sum_l=0^infty sum_m=-l^l left\n     mathrmi^l\n     Y_lm(hatpmbk)\n     delta_0l\n     delta_0m\n     int_0^infty\n       j_l(kr)\n       mathrme^-alpha_i r^2\n       r^2\n       mathrmdr\n     right \n  = frac1sqrt2 pi^3\n     4 pi sqrt4pi\n     mathrmi^0\n     Y_00(hatpmbk)\n     int_0^infty\n       j_0(kr)\n       mathrme^-alpha_i r^2\n       r^2\n     mathrmdr \n  = frac12pisqrt2pi\n     4 pi\n     fracsqrt4pisqrt4pi\n     sqrtfracpi2\n     sqrtfrac2pi\n     int_0^infty\n       j_0(kr)\n       mathrme^-alpha_i r^2\n       r^2\n     mathrmdr \n  = frac1(2alpha_i)^frac32 mathrme^-frack^24 alpha_i\nendaligned\n\nFormula\n\nplane-wave expansion in spherical harmonics:\n\nmathrme^mathrmi pmbk cdot pmbr\n= \n4 pi sum_l=0^infty sum_m=-l^l\nmathrmi^l\nj_l(pr)\nY_lm(hatpmbk)\nY_lm^*(hatpmbr)\n\nspecial case of spherical harmonics:\n\nY_00(hatpmbr) = frac1sqrt4pi\n\northonormality of spherical harmonics:\n\nint_0^2pi\nint_0^pi\n    Y_lm(hatpmbr)^*\n    Y_lm(hatpmbr)\nsin(theta) \nmathrmd theta\nmathrmd varphi\n=\ndelta_ll\ndelta_mm\n\ncitation needed:\n\nsqrtfrac2pi\nint\nr^l\nj_l(kr)\nmathrme^-alpha r^2\nr^2\nmathrmd r\n=\nfrac1(2alpha)^l+frac32\nk^l e^-frack^24alpha\n\n\n\n\n\n","category":"type"},{"location":"Rayleigh–Ritz/#TwoBody.ContractedBasis-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.ContractedBasis","text":"ContractedBasis([c1, c2, ...], [basis1, basis2, ...])\n\nphi = sum_i c_i phi_i\n\n\n\n\n\n","category":"type"},{"location":"Rayleigh–Ritz/#Matrix","page":"Rayleigh–Ritz Method","title":"Matrix","text":"","category":"section"},{"location":"Rayleigh–Ritz/#TwoBody.matrix-Tuple{BasisSet}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.matrix","text":"matrix(basisset::BasisSet)\n\nThis function returns the overlap matrix pmbS. The element is written as S_ij = langle phi_i  phi_j rangle.\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.matrix-Tuple{Hamiltonian, BasisSet}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.matrix","text":"matrix(hamiltonian::Hamiltonian, basisset::BasisSet)\n\nThis function returns the Hamiltonian matrix pmbH. The element is written as H_ij = langle phi_i  hatH  phi_j rangle.\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#Matrix-Elements","page":"Rayleigh–Ritz Method","title":"Matrix Elements","text":"","category":"section"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  S_ij\n   = langle phi_i  phi_j rangle\n  = int\n     phi_i^*(r)\n     phi_j(r)\n     mathrmd pmbr \n  = iiint\n     mathrme^-alpha_i r^2\n     mathrme^-alpha_j r^2\n     r^2 sintheta \n     mathrmd r\n     mathrmd theta\n     mathrmd varphi \n  = int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^2 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times frac12^2 sqrtfracpia^3 \n  = underlineleft( fracpialpha_i + alpha_j right)^32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n exp left(-a r^2right) mathrmdr = frac(2n-1)2^n+1 sqrtfracpia^2n+1\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{Hamiltonian, Basis, Basis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::Hamiltonian, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  H_ij\n  = langle phi_i  hatH  phi_j rangle \n  = langle phi_i  sum_k hato_k  phi_j rangle \n  = sum_k langle phi_i  hato_k  phi_j rangle \nendaligned\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{RestEnergy, SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::RestEnergy, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  mc^2  phi_j rangle\n  = mc^2 langle phi_i  phi_j rangle \n  = mc^2 iiint\n     phi_i^*(r)\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = mc^2\n     int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^2 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = mc^2 times 2pi times 2 times frac12^2 sqrtfracpia^3 \n  = underlinemc^2 left( fracpialpha_i + alpha_j right)^32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n exp left(-a r^2right) mathrmdr = frac(2n-1)2^n+1 sqrtfracpia^2n+1\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{TwoBody.Laplacian, SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::Laplacian, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  nabla^2  phi_j rangle\n  = underline\n      -6 fracalpha_i alpha_j pi^frac32(alpha_i + alpha_j)^frac52\n    \nendaligned\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{NonRelativisticKinetic, SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::NonRelativisticKinetic, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nDerivation (without Green's identity)\n\nbeginaligned\n  T_ij = langle phi_i  hatT  phi_j rangle\n  = iiint\n     mathrme^-alpha_i r^2\n     left -frachbar^22mu nabla^2 right\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = -frachbar^22mu iiint\n     mathrme^-alpha_i r^2\n     left nabla^2 right\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = -frachbar^22mu iiint\n     mathrme^-alpha_i r^2\n     left -6alpha_j + 4alpha_j^2 r^2 right\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = -frachbar^22mu iint\n     sintheta mathrmdtheta mathrmdvarphi\n     int\n     left -6alpha_j + 4alpha_j^2 r^2 right\n     r^2 mathrme^-(alpha_i + alpha_j) r^2\n     mathrmdr \n  = -frachbar^22mu cdot 4pi\n     left\n        -6alpha_j   mathrmGGI(2 alpha_i + alpha_j)\n        +4alpha_j^2 mathrmGGI(4 alpha_i + alpha_j)\n     right\n     \n  = -frachbar^22mu cdot 4pi\n     left\n        -6alpha_j   fracGammaleft( frac32 right)2 (alpha_i + alpha_j)^frac32\n        +4alpha_j^2 fracGammaleft( frac52 right)2 (alpha_i + alpha_j)^frac52\n     right \n  = -frachbar^22mu cdot 4pi\n     left\n        -6alpha_j   frac sqrtpi22 (alpha_i + alpha_j)^frac32\n        +4alpha_j^2 frac3sqrtpi42 (alpha_i + alpha_j)^frac52\n     right \n  = -frachbar^22mu cdot 4pi\n     left\n        fracalpha_jalpha_i + alpha_j - 1\n     right\n     cdot 6 alpha_j cdot fracsqrtpi22 (alpha_i + alpha_j)^frac32\n     \n  = -frachbar^22mu cdot 4pi\n     left\n        - fracalpha_ialpha_i + alpha_j\n     right\n     cdot 6 alpha_j cdot fracsqrtpi22 (alpha_i + alpha_j)^frac32\n     \n  = underline\n        frachbar^22mu\n        cdot 6\n        cdot fracalpha_i alpha_j pi^frac32(alpha_i + alpha_j)^frac52\n     \nendaligned\n\nDerivation (with Green's identity)\n\nbeginaligned\n  T_ij = langle phi_i  hatT  phi_j rangle\n  = iiint\n     mathrme^-alpha_i r^2\n     left -frachbar^22mu nabla^2 right\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = -frachbar^22mu iiint\n     mathrme^-alpha_i r^2\n     nabla^2\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = frachbar^22mu iiint\n     left nabla mathrme^-alpha_i r^2 right\n     left nabla mathrme^-alpha_j r^2 right\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = frachbar^22mu iiint\n     left -2 alpha_i r mathrme^-alpha_i r^2 right\n     left -2 alpha_j r mathrme^-alpha_j r^2 right\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = frachbar^22mu cdot 4 alpha_i alpha_j iiint\n     left r mathrme^-alpha_i r^2 right\n     left r mathrme^-alpha_j r^2 right\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = frachbar^22mu\n     cdot 4 alpha_i alpha_j\n     iint sintheta mathrmdtheta mathrmdvarphi\n     int r^4\n     mathrme^- (alpha_i + alpha_j) r^2\n     mathrmdr \n  = frachbar^22mu\n     cdot 4 alpha_i alpha_j\n     cdot 4 pi\n     cdot mathrmGGI(4 alpha_i + alpha_j) \n  = frachbar^22mu\n     cdot 4 alpha_i alpha_j\n     cdot 4 pi\n     cdot fracGammaleft( frac52 right)2 (alpha_i + alpha_j)^frac52 \n  = frachbar^22mu\n     cdot 4 alpha_i alpha_j\n     cdot 4 pi\n     cdot frac3sqrtpi42 (alpha_i + alpha_j)^frac52 \n  = underline\n        frachbar^22mu\n        cdot 6\n        cdot fracalpha_i alpha_j pi^frac32(alpha_i + alpha_j)^frac52\n     \nendaligned\n\nFormula\n\nGreen's first identity:\n\nbeginaligned\n  iiint_V\n  f pmbnabla^2 g\n   mathrmdV\n+ iiint_V\n  pmbnabla f cdot\n  pmbnabla g\n   mathrmdV\n= iint_partial V\n  f pmbnabla g cdot pmbn\n   mathrmdS\nendaligned\n\ngeneralized Gaussian integral:\n\nbeginaligned\n  mathrmGGI(nb)\n  = int_0^infty x^n exp left(-b x^2right) mathrmdx\n  = fracGammaleft( fracn+12 right)2 b^fracn+12\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{ConstantPotential, SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::ConstantPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  c  phi_j rangle\n  = c langle phi_i  phi_j rangle \n  = c iiint\n     phi_i^*(r)\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = c\n     int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^2 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = c times 2pi times 2 times frac12^2 sqrtfracpia^3 \n  = underlinec left( fracpialpha_i + alpha_j right)^32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n exp left(-a r^2right) mathrmdr = frac(2n-1)2^n+1 sqrtfracpia^2n+1\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{LinearPotential, SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::LinearPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  r  phi_j rangle\n  = iiint\n     phi_i^*(r)\n     times r times\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^3 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times frac12 (alpha_i + alpha_j)^2 \n  = underlinefrac2pi(alpha_i + alpha_j)^2\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n+1 exp left(-a r^2right) mathrmdr = fracn2 a^n+1\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{CoulombPotential, SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::CoulombPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  frac1r  phi_j rangle\n  = iiint\n    phi_i^*(r)\n    times frac1r times\n    phi_j(r)\n    r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = int_0^2pi mathrmdvarphi\n    int_0^pi sintheta mathrmdtheta\n    int_0^infty r mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times frac02 (alpha_i + alpha_j) \n  = underlinefrac2pialpha_i + alpha_j\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n+1 exp left(-a r^2right) mathrmdr = fracn2 a^n+1\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{PowerLawPotential, SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::PowerLawPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  r^n  phi_j rangle\n  = iiint\n     phi_i^*(r)\n     times r^n times\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^n+2 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times fracGammaleft( fracn+32 right)2 (alpha_i + alpha_j)^fracn+32 \n  = underline2pifracGammaleft( fracn+32 right)(alpha_i + alpha_j)^fracn+32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^n exp left(-a r^2right) mathrmdr = fracGammaleft( fracn+12 right)2 a^fracn+12\n\n\n\n\n\n","category":"method"},{"location":"Rayleigh–Ritz/#TwoBody.element-Tuple{GaussianPotential, SimpleGaussianBasis, SimpleGaussianBasis}-Rayleigh–Ritz","page":"Rayleigh–Ritz Method","title":"TwoBody.element","text":"element(o::GaussianPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  exp(-br^2)  phi_j rangle\n  = iiint\n     phi_i^*(r)\n     times exp(-br^2) times\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^2 mathrme^-(b+alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times frac12^2 sqrtfracpi(b + alpha_i + alpha_j)^2cdot1+1 \n  = underlineleft( fracpib + alpha_i + alpha_j right)^32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n exp left(-a r^2right) mathrmdr = frac(2n-1)2^n+1 sqrtfracpia^2n+1\n\n\n\n\n\n","category":"method"},{"location":"Hamiltonian/#Hamiltonian","page":"Hamiltonian","title":"Hamiltonian","text":"","category":"section"},{"location":"Hamiltonian/#TwoBody.Hamiltonian-Hamiltonian","page":"Hamiltonian","title":"TwoBody.Hamiltonian","text":"Hamiltonian(operator1, operator2, ...)\n\nhatH = sum_i hato_i\n\nThe Hamiltonian is the input for each solver. This is an example for the non-relativistic Hamiltonian of hydrogen atom in atomic units:\n\nhatH = \n- frac12 nabla^2\n- frac1r\n\nH = Hamiltonian(\n  NonRelativisticKinetic(ℏ =1 , m = 1),\n  CoulombPotential(coefficient = -1),\n)\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#Operators","page":"Hamiltonian","title":"Operators","text":"","category":"section"},{"location":"Hamiltonian/#TwoBody.NonRelativisticKinetic-Hamiltonian","page":"Hamiltonian","title":"TwoBody.NonRelativisticKinetic","text":"NonRelativisticKinetic(ℏ=1, m=1)\n\n-frachbar^22m nabla^2\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.RestEnergy-Hamiltonian","page":"Hamiltonian","title":"TwoBody.RestEnergy","text":"RestEnergy(c=1, m=1)\n\nm c^2\n\nUse c = 137.035999177 (from 2022 CODATA) in the atomic units.\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.RelativisticCorrection-Hamiltonian","page":"Hamiltonian","title":"TwoBody.RelativisticCorrection","text":"RelativisticCorrection(c=1, m=1, n=2) The p^{2n} term of the Taylor expansion:\n\nbeginaligned\n  sqrtp^2 c^2 + m^2 c^4\n  = m times c^2 \n  + 1  2    m         times p^2 (n=1) \n  - 1  8    m^3  c^2 times p^4 (n=2) \n  + 1  16   m^5  c^4 times p^6 (n=3) \n  - 5  128  m^7  c^6 times p^8 (n=4) \n  + cdots\nendaligned\n\nUse c = 137.035999177 (from 2022 CODATA) in the atomic units.\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.RelativisticKinetic-Hamiltonian","page":"Hamiltonian","title":"TwoBody.RelativisticKinetic","text":"RelativisticKinetic(c=1, m=1)\n\nsqrtp^2 c^2 + m^2 c^4 - m c^2\n\nUse c = 137.035999177 (from 2022 CODATA) in the atomic units.\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.ConstantPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.ConstantPotential","text":"ConstantPotential(constant=1)\n\n+ c\n\nArguments Symbol\nconstant c\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.LinearPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.LinearPotential","text":"LinearPotential(coefficient=1)\n\n+ ar\n\nArguments Symbol\ncoefficient a\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.CoulombPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.CoulombPotential","text":"CoulombPotential(coefficient=1)\n\n+ fracar\n\nArguments Symbol\ncoefficient a\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.PowerLawPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.PowerLawPotential","text":"PowerLawPotential(coefficient=1, exponent=1)\n\n+ ar^n\n\nArguments Symbol\ncoefficient a\nexponent n\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.GaussianPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.GaussianPotential","text":"GaussianPotential(coefficient=1, exponent=1)\n\n+ a exp(- b r^2)\n\nArguments Symbol\ncoefficient a\nexponent b\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.ExponentialPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.ExponentialPotential","text":"ExponentialPotential(coefficient=1, exponent=1)\n\n+ a exp(- b r)\n\nArguments Symbol\ncoefficient a\nexponent b\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.YukawaPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.YukawaPotential","text":"YukawaPotential(coefficient=1, exponent=1)\n\n+ fracar exp(- b r)\n\nArguments Symbol\ncoefficient a\nexponent b\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.DeltaPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.DeltaPotential","text":"DeltaPotential(coefficient=1)\n\n+ a δ(r)\n\nArguments Symbol\ncoefficient a\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.FunctionPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.FunctionPotential","text":"FunctionPotential(f)\n\n+ f(r)\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonian/#TwoBody.UniformGridPotential-Hamiltonian","page":"Hamiltonian","title":"TwoBody.UniformGridPotential","text":"UniformGridPotential(R, V)\n\n\n\n\n\n","category":"type"},{"location":"#TwoBody.jl","page":"Home","title":"TwoBody.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"TwoBody.jl: a Julia package for quantum mechanical two-body problems","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run the following code on the REPL or Jupyter Notebook to install this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/ohno/TwoBody.jl.git\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run the following code before each use.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TwoBody","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define the Hamiltoninan. This is an example for the non-relativistic Hamiltonian of hydrogen atom in atomic units:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = \n- frac12 nabla^2\n- frac1r","category":"page"},{"location":"","page":"Home","title":"Home","text":"H = Hamiltonian(\n  NonRelativisticKinetic(ℏ = 1 , m = 1),\n  CoulombPotential(coefficient = -1),\n)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The usage depends on the method. Define the basis set for the Rayleigh–Ritz Method:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n  phi_1(r) = exp(-1300773 r^2) \n  phi_2(r) = exp(-1962079 r^2) \n  phi_3(r) = exp(-0444529 r^2) \n  phi_4(r) = exp(-01219492 r^2)\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"BS = BasisSet(\n  SimpleGaussianBasis(13.00773),\n  SimpleGaussianBasis(1.962079),\n  SimpleGaussianBasis(0.444529),\n  SimpleGaussianBasis(0.1219492),\n)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should find","category":"page"},{"location":"","page":"Home","title":"Home","text":"E_n=1 = -0499278E_mathrmh","category":"page"},{"location":"","page":"Home","title":"Home","text":"which is amazingly good for only four basis functions according to Thijssen(2007). The exact ground-state energy is -05E_mathrmh.","category":"page"},{"location":"","page":"Home","title":"Home","text":"solve(H, BS)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The wave function is also good. However, the Gaussian basis does not satisfy the Kato’s cusp condition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# solve\nres = solve(H, BS, info=0)\n\n# benchmark\nimport Antique\nHA = Antique.HydrogenAtom(Z=1, Eₕ=1.0, a₀=1.0, mₑ=1.0, ℏ=1.0)\n\n# plot\nusing CairoMakie\nfig = Figure(size=(420,300), fontsize=11.5, backgroundcolor=:transparent)\naxis = Axis(fig[1,1], xlabel=L\"$r / a_0$\", ylabel=L\"$\\psi(r) / a_0^{-3/2}$\", ylabelsize=16.5, xlabelsize=16.5, limits=(0,4,0,1.1/sqrt(π)))\nlines!(axis, 0..5, r -> abs(res.ψ[1](r)), label=\"TwoBody.jl\")\nlines!(axis, 0..5, r -> abs(Antique.ψ(HA,r,0,0)), linestyle=:dash, color=:black, label=\"Antique.jl\")\naxislegend(axis, position=:rt, framevisible=false)\nfig","category":"page"},{"location":"#API-reference","page":"Home","title":"API reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"API/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"API/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"API/#TwoBody.Basis","page":"API reference","title":"TwoBody.Basis","text":"Basis is an abstract type.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.BasisSet","page":"API reference","title":"TwoBody.BasisSet","text":"BasisSet(basis1, basis2, ...)\n\n phi_1 phi_2 phi_3 cdots  \n\nThe basis set is the input for Rayleigh–Ritz method. You can define the basis set like this:\n\nbeginaligned\n  phi_1(r) = exp(-1300773 r^2) \n  phi_2(r) = exp(-1962079 r^2) \n  phi_3(r) = exp(-0444529 r^2) \n  phi_4(r) = exp(-01219492 r^2)\nendaligned\n\nBS = BasisSet(\n  SimpleGaussianBasis(13.00773),\n  SimpleGaussianBasis(1.962079),\n  SimpleGaussianBasis(0.444529),\n  SimpleGaussianBasis(0.1219492),\n)\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.ConstantPotential","page":"API reference","title":"TwoBody.ConstantPotential","text":"ConstantPotential(constant=1)\n\n+ c\n\nArguments Symbol\nconstant c\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.ContractedBasis","page":"API reference","title":"TwoBody.ContractedBasis","text":"ContractedBasis([c1, c2, ...], [basis1, basis2, ...])\n\nphi = sum_i c_i phi_i\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.CoulombPotential","page":"API reference","title":"TwoBody.CoulombPotential","text":"CoulombPotential(coefficient=1)\n\n+ fracar\n\nArguments Symbol\ncoefficient a\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.DeltaPotential","page":"API reference","title":"TwoBody.DeltaPotential","text":"DeltaPotential(coefficient=1)\n\n+ a δ(r)\n\nArguments Symbol\ncoefficient a\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.ExponentialPotential","page":"API reference","title":"TwoBody.ExponentialPotential","text":"ExponentialPotential(coefficient=1, exponent=1)\n\n+ a exp(- b r)\n\nArguments Symbol\ncoefficient a\nexponent b\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.FiniteDifferenceMethod","page":"API reference","title":"TwoBody.FiniteDifferenceMethod","text":"FiniteDifferenceMethod(Δr=0.1, rₘₐₓ=50.0, R=Δr:Δr:rₘₐₓ, l=0, direction=:c, solver=:LinearAlgebra)\n\nArguments Default Description\nΔr::Real 0.1 Radial grid spacing. A uniform grid spacing is used, r_i+1 = r_i + Delta r.\nrₘₐₓ::Real 50.0 The maximum value of the radial grid. This value is not directly used in the calculation, but it is used to determine the R.\nR::StepRangeLen Δr:Δr:rₘₐₓ Radial grid. The origin must be excluded from the grid to avoid divergence of the Coulomb potential and the centrifugal potential at the origin.\nl::Int 0 Angular momentum quantum number. This is a positive integer, 0 leq l.\ndirection::Symbol :c The direction of the finite difference, :c for central, :f for forward, :b for backward.\nsolver::Symbol :LinearAlgebra The solver for eigenvalue problem, :LinearAlgebra or :ArnoldiMethod.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.FunctionPotential","page":"API reference","title":"TwoBody.FunctionPotential","text":"FunctionPotential(f)\n\n+ f(r)\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.GaussianBasis","page":"API reference","title":"TwoBody.GaussianBasis","text":"GaussianBasis(a=1, l=0, m=0)\n\nphi_i(r θ φ) = N _il r^l exp(-a_i r^2) Y_l^m(θ φ)\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.GaussianPotential","page":"API reference","title":"TwoBody.GaussianPotential","text":"GaussianPotential(coefficient=1, exponent=1)\n\n+ a exp(- b r^2)\n\nArguments Symbol\ncoefficient a\nexponent b\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.GeometricBasisSet","page":"API reference","title":"TwoBody.GeometricBasisSet","text":"GeometricBasisSet(basistype, r₁, rₙ, n; nₘᵢₙ=1, nₘₐₓ=n)\n\nThis is a basis set with exponentials generated by geometric().\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.Hamiltonian","page":"API reference","title":"TwoBody.Hamiltonian","text":"Hamiltonian(operator1, operator2, ...)\n\nhatH = sum_i hato_i\n\nThe Hamiltonian is the input for each solver. This is an example for the non-relativistic Hamiltonian of hydrogen atom in atomic units:\n\nhatH = \n- frac12 nabla^2\n- frac1r\n\nH = Hamiltonian(\n  NonRelativisticKinetic(ℏ =1 , m = 1),\n  CoulombPotential(coefficient = -1),\n)\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.KineticTerm","page":"API reference","title":"TwoBody.KineticTerm","text":"KineticTerm <: Operator is an abstract type.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.Laplacian","page":"API reference","title":"TwoBody.Laplacian","text":"Laplacian(coefficient=1)\n\n+ anabla^2\n\nArguments Symbol\ncoefficient a\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.LinearPotential","page":"API reference","title":"TwoBody.LinearPotential","text":"LinearPotential(coefficient=1)\n\n+ ar\n\nArguments Symbol\ncoefficient a\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.NonRelativisticKinetic","page":"API reference","title":"TwoBody.NonRelativisticKinetic","text":"NonRelativisticKinetic(ℏ=1, m=1)\n\n-frachbar^22m nabla^2\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.Operator","page":"API reference","title":"TwoBody.Operator","text":"Operator is an abstract type.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.PotentialTerm","page":"API reference","title":"TwoBody.PotentialTerm","text":"PotentialTerm <: Operator is an abstract type.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.PowerLawPotential","page":"API reference","title":"TwoBody.PowerLawPotential","text":"PowerLawPotential(coefficient=1, exponent=1)\n\n+ ar^n\n\nArguments Symbol\ncoefficient a\nexponent n\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.PrimitiveBasis","page":"API reference","title":"TwoBody.PrimitiveBasis","text":"PrimitiveBasis <: Basis is an abstract type.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.RelativisticCorrection","page":"API reference","title":"TwoBody.RelativisticCorrection","text":"RelativisticCorrection(c=1, m=1, n=2) The p^{2n} term of the Taylor expansion:\n\nbeginaligned\n  sqrtp^2 c^2 + m^2 c^4\n  = m times c^2 \n  + 1  2    m         times p^2 (n=1) \n  - 1  8    m^3  c^2 times p^4 (n=2) \n  + 1  16   m^5  c^4 times p^6 (n=3) \n  - 5  128  m^7  c^6 times p^8 (n=4) \n  + cdots\nendaligned\n\nUse c = 137.035999177 (from 2022 CODATA) in the atomic units.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.RelativisticKinetic","page":"API reference","title":"TwoBody.RelativisticKinetic","text":"RelativisticKinetic(c=1, m=1)\n\nsqrtp^2 c^2 + m^2 c^4 - m c^2\n\nUse c = 137.035999177 (from 2022 CODATA) in the atomic units.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.RestEnergy","page":"API reference","title":"TwoBody.RestEnergy","text":"RestEnergy(c=1, m=1)\n\nm c^2\n\nUse c = 137.035999177 (from 2022 CODATA) in the atomic units.\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.SimpleGaussianBasis","page":"API reference","title":"TwoBody.SimpleGaussianBasis","text":"SimpleGaussianBasis(a=1)\n\nnote: Note\nThis basis is not normalized and only for s-wave.\n\nPosition-Space\n\nphi_i(pmbr) = exp(-a_i r^2)\n\nMomentum-Space\n\nphi_i(pmbk)  = frac1(2a_i)^frac32 exp(-k^24a_i)\n\nProof (Fourier Transform)\n\nbeginaligned\n  phi_n(pmbk)\n  = frac1sqrt2 pi^3\n     int\n     phi_n(pmbr)\n     mathrme^mathrmi pmbk cdot pmbr\n     mathrmdpmbr \n  = frac1sqrt2 pi^3\n     int\n     phi_n(pmbr)\n     mathrme^mathrmi pmbk cdot pmbr \n     r^2 sin (theta)\n     mathrmdr\n     mathrmdtheta\n     mathrmd varphi \n  = frac1sqrt2 pi^3\n     iiint\n     mathrme^-alpha_i r^2\n     sqrt4pi Y_00(hatpmbr)\n     left\n       4 pi sum_l=0^infty sum_m=-l^l\n       mathrmi^l\n       j_l(pr)\n       Y_lm(hatpmbk)\n       Y_lm^*(hatpmbr)\n     right\n     r^2 sintheta\n     mathrmd r\n     mathrmd theta\n     mathrmd varphi \n  = frac1sqrt2 pi^3\n     4 pi sqrt4pi sum_l=0^infty sum_m=-l^l left\n     mathrmi^l\n     Y_lm(hatpmbk)\n     int_0^2 pi \n     int_0^pi\n       Y_00(hatpmbr)\n       Y_lm^*(hatpmbr)\n       sin (theta)\n     mathrmd theta\n     mathrmd varphi\n     int_0^infty\n       j_l(pr)\n       mathrme^-alpha_i r^2\n       r^2\n       mathrmdr\n     right\n  =  frac1sqrt2 pi^3\n     4 pi sqrt4pi sum_l=0^infty sum_m=-l^l left\n     mathrmi^l\n     Y_lm(hatpmbk)\n     delta_0l\n     delta_0m\n     int_0^infty\n       j_l(kr)\n       mathrme^-alpha_i r^2\n       r^2\n       mathrmdr\n     right \n  = frac1sqrt2 pi^3\n     4 pi sqrt4pi\n     mathrmi^0\n     Y_00(hatpmbk)\n     int_0^infty\n       j_0(kr)\n       mathrme^-alpha_i r^2\n       r^2\n     mathrmdr \n  = frac12pisqrt2pi\n     4 pi\n     fracsqrt4pisqrt4pi\n     sqrtfracpi2\n     sqrtfrac2pi\n     int_0^infty\n       j_0(kr)\n       mathrme^-alpha_i r^2\n       r^2\n     mathrmdr \n  = frac1(2alpha_i)^frac32 mathrme^-frack^24 alpha_i\nendaligned\n\nFormula\n\nplane-wave expansion in spherical harmonics:\n\nmathrme^mathrmi pmbk cdot pmbr\n= \n4 pi sum_l=0^infty sum_m=-l^l\nmathrmi^l\nj_l(pr)\nY_lm(hatpmbk)\nY_lm^*(hatpmbr)\n\nspecial case of spherical harmonics:\n\nY_00(hatpmbr) = frac1sqrt4pi\n\northonormality of spherical harmonics:\n\nint_0^2pi\nint_0^pi\n    Y_lm(hatpmbr)^*\n    Y_lm(hatpmbr)\nsin(theta) \nmathrmd theta\nmathrmd varphi\n=\ndelta_ll\ndelta_mm\n\ncitation needed:\n\nsqrtfrac2pi\nint\nr^l\nj_l(kr)\nmathrme^-alpha r^2\nr^2\nmathrmd r\n=\nfrac1(2alpha)^l+frac32\nk^l e^-frack^24alpha\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.UniformGridPotential","page":"API reference","title":"TwoBody.UniformGridPotential","text":"UniformGridPotential(R, V)\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.YukawaPotential","page":"API reference","title":"TwoBody.YukawaPotential","text":"YukawaPotential(coefficient=1, exponent=1)\n\n+ fracar exp(- b r)\n\nArguments Symbol\ncoefficient a\nexponent b\n\n\n\n\n\n","category":"type"},{"location":"API/#TwoBody.element-Tuple{ConstantPotential, SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(o::ConstantPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  c  phi_j rangle\n  = c langle phi_i  phi_j rangle \n  = c iiint\n     phi_i^*(r)\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = c\n     int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^2 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = c times 2pi times 2 times frac12^2 sqrtfracpia^3 \n  = underlinec left( fracpialpha_i + alpha_j right)^32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n exp left(-a r^2right) mathrmdr = frac(2n-1)2^n+1 sqrtfracpia^2n+1\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{CoulombPotential, SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(o::CoulombPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  frac1r  phi_j rangle\n  = iiint\n    phi_i^*(r)\n    times frac1r times\n    phi_j(r)\n    r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = int_0^2pi mathrmdvarphi\n    int_0^pi sintheta mathrmdtheta\n    int_0^infty r mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times frac02 (alpha_i + alpha_j) \n  = underlinefrac2pialpha_i + alpha_j\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n+1 exp left(-a r^2right) mathrmdr = fracn2 a^n+1\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{GaussianPotential, SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(o::GaussianPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  exp(-br^2)  phi_j rangle\n  = iiint\n     phi_i^*(r)\n     times exp(-br^2) times\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^2 mathrme^-(b+alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times frac12^2 sqrtfracpi(b + alpha_i + alpha_j)^2cdot1+1 \n  = underlineleft( fracpib + alpha_i + alpha_j right)^32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n exp left(-a r^2right) mathrmdr = frac(2n-1)2^n+1 sqrtfracpia^2n+1\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{Hamiltonian, Basis, Basis}","page":"API reference","title":"TwoBody.element","text":"element(o::Hamiltonian, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  H_ij\n  = langle phi_i  hatH  phi_j rangle \n  = langle phi_i  sum_k hato_k  phi_j rangle \n  = sum_k langle phi_i  hato_k  phi_j rangle \nendaligned\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{LinearPotential, SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(o::LinearPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  r  phi_j rangle\n  = iiint\n     phi_i^*(r)\n     times r times\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^3 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times frac12 (alpha_i + alpha_j)^2 \n  = underlinefrac2pi(alpha_i + alpha_j)^2\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n+1 exp left(-a r^2right) mathrmdr = fracn2 a^n+1\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{NonRelativisticKinetic, SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(o::NonRelativisticKinetic, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nDerivation (without Green's identity)\n\nbeginaligned\n  T_ij = langle phi_i  hatT  phi_j rangle\n  = iiint\n     mathrme^-alpha_i r^2\n     left -frachbar^22mu nabla^2 right\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = -frachbar^22mu iiint\n     mathrme^-alpha_i r^2\n     left nabla^2 right\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = -frachbar^22mu iiint\n     mathrme^-alpha_i r^2\n     left -6alpha_j + 4alpha_j^2 r^2 right\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = -frachbar^22mu iint\n     sintheta mathrmdtheta mathrmdvarphi\n     int\n     left -6alpha_j + 4alpha_j^2 r^2 right\n     r^2 mathrme^-(alpha_i + alpha_j) r^2\n     mathrmdr \n  = -frachbar^22mu cdot 4pi\n     left\n        -6alpha_j   mathrmGGI(2 alpha_i + alpha_j)\n        +4alpha_j^2 mathrmGGI(4 alpha_i + alpha_j)\n     right\n     \n  = -frachbar^22mu cdot 4pi\n     left\n        -6alpha_j   fracGammaleft( frac32 right)2 (alpha_i + alpha_j)^frac32\n        +4alpha_j^2 fracGammaleft( frac52 right)2 (alpha_i + alpha_j)^frac52\n     right \n  = -frachbar^22mu cdot 4pi\n     left\n        -6alpha_j   frac sqrtpi22 (alpha_i + alpha_j)^frac32\n        +4alpha_j^2 frac3sqrtpi42 (alpha_i + alpha_j)^frac52\n     right \n  = -frachbar^22mu cdot 4pi\n     left\n        fracalpha_jalpha_i + alpha_j - 1\n     right\n     cdot 6 alpha_j cdot fracsqrtpi22 (alpha_i + alpha_j)^frac32\n     \n  = -frachbar^22mu cdot 4pi\n     left\n        - fracalpha_ialpha_i + alpha_j\n     right\n     cdot 6 alpha_j cdot fracsqrtpi22 (alpha_i + alpha_j)^frac32\n     \n  = underline\n        frachbar^22mu\n        cdot 6\n        cdot fracalpha_i alpha_j pi^frac32(alpha_i + alpha_j)^frac52\n     \nendaligned\n\nDerivation (with Green's identity)\n\nbeginaligned\n  T_ij = langle phi_i  hatT  phi_j rangle\n  = iiint\n     mathrme^-alpha_i r^2\n     left -frachbar^22mu nabla^2 right\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = -frachbar^22mu iiint\n     mathrme^-alpha_i r^2\n     nabla^2\n     mathrme^-alpha_j r^2\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = frachbar^22mu iiint\n     left nabla mathrme^-alpha_i r^2 right\n     left nabla mathrme^-alpha_j r^2 right\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = frachbar^22mu iiint\n     left -2 alpha_i r mathrme^-alpha_i r^2 right\n     left -2 alpha_j r mathrme^-alpha_j r^2 right\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = frachbar^22mu cdot 4 alpha_i alpha_j iiint\n     left r mathrme^-alpha_i r^2 right\n     left r mathrme^-alpha_j r^2 right\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = frachbar^22mu\n     cdot 4 alpha_i alpha_j\n     iint sintheta mathrmdtheta mathrmdvarphi\n     int r^4\n     mathrme^- (alpha_i + alpha_j) r^2\n     mathrmdr \n  = frachbar^22mu\n     cdot 4 alpha_i alpha_j\n     cdot 4 pi\n     cdot mathrmGGI(4 alpha_i + alpha_j) \n  = frachbar^22mu\n     cdot 4 alpha_i alpha_j\n     cdot 4 pi\n     cdot fracGammaleft( frac52 right)2 (alpha_i + alpha_j)^frac52 \n  = frachbar^22mu\n     cdot 4 alpha_i alpha_j\n     cdot 4 pi\n     cdot frac3sqrtpi42 (alpha_i + alpha_j)^frac52 \n  = underline\n        frachbar^22mu\n        cdot 6\n        cdot fracalpha_i alpha_j pi^frac32(alpha_i + alpha_j)^frac52\n     \nendaligned\n\nFormula\n\nGreen's first identity:\n\nbeginaligned\n  iiint_V\n  f pmbnabla^2 g\n   mathrmdV\n+ iiint_V\n  pmbnabla f cdot\n  pmbnabla g\n   mathrmdV\n= iint_partial V\n  f pmbnabla g cdot pmbn\n   mathrmdS\nendaligned\n\ngeneralized Gaussian integral:\n\nbeginaligned\n  mathrmGGI(nb)\n  = int_0^infty x^n exp left(-b x^2right) mathrmdx\n  = fracGammaleft( fracn+12 right)2 b^fracn+12\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{PowerLawPotential, SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(o::PowerLawPotential, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  r^n  phi_j rangle\n  = iiint\n     phi_i^*(r)\n     times r^n times\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^n+2 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times fracGammaleft( fracn+32 right)2 (alpha_i + alpha_j)^fracn+32 \n  = underline2pifracGammaleft( fracn+32 right)(alpha_i + alpha_j)^fracn+32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^n exp left(-a r^2right) mathrmdr = fracGammaleft( fracn+12 right)2 a^fracn+12\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{RestEnergy, SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(o::RestEnergy, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  mc^2  phi_j rangle\n  = mc^2 langle phi_i  phi_j rangle \n  = mc^2 iiint\n     phi_i^*(r)\n     phi_j(r)\n     r^2 sintheta mathrmdr mathrmdtheta mathrmdvarphi \n  = mc^2\n     int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^2 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = mc^2 times 2pi times 2 times frac12^2 sqrtfracpia^3 \n  = underlinemc^2 left( fracpialpha_i + alpha_j right)^32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n exp left(-a r^2right) mathrmdr = frac(2n-1)2^n+1 sqrtfracpia^2n+1\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  S_ij\n   = langle phi_i  phi_j rangle\n  = int\n     phi_i^*(r)\n     phi_j(r)\n     mathrmd pmbr \n  = iiint\n     mathrme^-alpha_i r^2\n     mathrme^-alpha_j r^2\n     r^2 sintheta \n     mathrmd r\n     mathrmd theta\n     mathrmd varphi \n  = int_0^2pi mathrmdvarphi\n     int_0^pi sintheta mathrmdtheta\n     int_0^infty r^2 mathrme^-(alpha_i + alpha_j) r^2 mathrmdr \n  = 2pi times 2 times frac12^2 sqrtfracpia^3 \n  = underlineleft( fracpialpha_i + alpha_j right)^32\nendaligned\n\nIntegral Formula:\n\nint_0^infty r^2n exp left(-a r^2right) mathrmdr = frac(2n-1)2^n+1 sqrtfracpia^2n+1\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.element-Tuple{TwoBody.Laplacian, SimpleGaussianBasis, SimpleGaussianBasis}","page":"API reference","title":"TwoBody.element","text":"element(o::Laplacian, SGB1::SimpleGaussianBasis, SGB2::SimpleGaussianBasis)\n\nbeginaligned\n  langle phi_i  nabla^2  phi_j rangle\n  = underline\n      -6 fracalpha_i alpha_j pi^frac32(alpha_i + alpha_j)^frac52\n    \nendaligned\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.geometric-Tuple{Any, Any, Int64}","page":"API reference","title":"TwoBody.geometric","text":"Exponents of Gaussian basis functions are given by geometric progression:\n\nbeginaligned\n   v_i = frac1r_i^2 \n   r_i = r_1 a^i-1\nendaligned\n\nThis function return array of nu_i:\n\n(r_1 r_n n n_mathrmmax) mapsto (nu_1 nu_2 cdots nu_n-1 nu_n nu_n+1 cdots nu_n_mathrmmax)\n\nUsually n = n_mathrmmax. Set nn_mathrmmax if you want to extend the geometric progression.\n\nExamples:\n\njulia> ν = TwoBody.geometric(0.1, 10.0, 5)\n5-element Vector{Float64}:\n 100.0\n  10.0\n   0.9999999999999997\n   0.09999999999999996\n   0.009999999999999995\n\njulia> ν = TwoBody.geometric(0.1, 10.0, 5, nₘₐₓ = 10)\n10-element Vector{Float64}:\n 100.0\n  10.0\n   0.9999999999999997\n   0.09999999999999996\n   0.009999999999999995\n   0.0009999999999999994\n   9.999999999999994e-5\n   9.999999999999992e-6\n   9.999999999999991e-7\n   9.999999999999988e-8\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.matrix-Tuple{BasisSet}","page":"API reference","title":"TwoBody.matrix","text":"matrix(basisset::BasisSet)\n\nThis function returns the overlap matrix pmbS. The element is written as S_ij = langle phi_i  phi_j rangle.\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.matrix-Tuple{Hamiltonian, BasisSet}","page":"API reference","title":"TwoBody.matrix","text":"matrix(hamiltonian::Hamiltonian, basisset::BasisSet)\n\nThis function returns the Hamiltonian matrix pmbH. The element is written as H_ij = langle phi_i  hatH  phi_j rangle.\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.matrix-Tuple{Hamiltonian, FiniteDifferenceMethod}","page":"API reference","title":"TwoBody.matrix","text":"matrix(o::Hamiltonian, method::FiniteDifferenceMethod)\n\nThe matrix for the Hamiltonian is a sum of matrices for each term,\n\npmbH = sum_i pmbO_i\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.matrix-Tuple{NonRelativisticKinetic, FiniteDifferenceMethod}","page":"API reference","title":"TwoBody.matrix","text":"matrix(o::NonRelativisticKinetic, method::FiniteDifferenceMethod)\n\nWe use the shorthand notation psi(r) = fracmathrmdpsimathrmdr(r) and psi(r) = fracmathrmd^2psimathrmdr^2(r). For the uniform grid spacing (r_i+1 = r_i + Delta r), the finite difference for the first derivative,\n\nfracmathrmdpsimathrmdr(r) = fracpsi(r+Delta r) - psi(r-Delta r)2Delta r + O(Delta r^2)\n\nis written as\n\nleft(beginarrayccccc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  psi(r_4) \n  vdots\nendarrayright)\nsimeq\nfrac12Delta r\nleft(beginarrayccccc\n   0   1   0   0 ldots \n  -1   0   1   0 ldots \n   0  -1   0   1 ldots \n   0   0  -1   0 ldots \n  vdots  vdots  vdots  vdots  ddots \nendarrayright)\nleft(beginarrayccccccc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  psi(r_4) \n  vdots\nendarrayright)\n\nand the finite difference for the second derivative,\n\nfracmathrmd^2mathrmdr^2(r) = fracpsi(r+Delta r) - 2f(r) + psi(r-Delta r)Delta r^2 + O(Delta r^2)\n\nis written as\n\nleft(beginarrayccccc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  psi(r_4) \n  vdots\nendarrayright)\nsimeq\nfrac1Delta r^2\nleft(beginarrayccccccc\n  -2   1   0   0  ldots \n   1  -2   1   0  ldots \n   0   1  -2   1  ldots \n   0   0   1  -2  ldots \n  vdots  vdots  vdots  vdots  ddots \nendarrayright)\nleft(beginarrayccccccc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  psi(r_4) \n  vdots\nendarrayright)\n\nSimilarly, the matrix for the kinetic energy,\n\nhatT\n=\n-frachbar^22mu\nleft\n      fracpartial^2partial r^2\n    + frac2r fracpartialpartial r\n    - fracl(l+1)r^2\nright\n\nis written as\n\npmbT\n= - frachbar^22mu\n  left\n    frac1Delta r^2\n    left(beginarrayccccccc\n      -2  1  0  ldots \n      1  -2  1  ldots \n      0  1  -2  ldots \n      vdots  vdots  vdots  ddots \n    endarrayright)\n    +\n    left(beginarrayccccccc\n       2r_1  0  0  ldots \n       0  2r_2  0  ldots \n       0  0  2r_3  ldots \n      vdots  vdots  vdots  ddots \n    endarrayright)\n    frac1Delta r\n    left(beginarrayccccccc\n       0   1   0  ldots \n      -1   0   1  ldots \n       0  -1   0  ldots \n      vdots  vdots  vdots  ddots \n    endarrayright)\n    - l(l+1)\n    left(beginarrayccccccc\n       1r_1^2  0  0  ldots \n       0  1r_2^2  0  ldots \n       0  0  1r_3^2  ldots \n      vdots  vdots  vdots  ddots \n    endarrayright)\n  right\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.matrix-Tuple{RestEnergy, FiniteDifferenceMethod}","page":"API reference","title":"TwoBody.matrix","text":"matrix(o::RestEnergy, method::FiniteDifferenceMethod)\n\nThe matrix for the rest energy mc^2 is a diagonal matrix,\n\nmc^2\nleft(beginarrayccccccc\n  1  0  0  ldots \n  0  1  0  ldots \n  0  0  1  ldots \n  vdots  vdots  vdots  ddots \nendarrayright)\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.matrix-Tuple{TwoBody.PotentialTerm, FiniteDifferenceMethod}","page":"API reference","title":"TwoBody.matrix","text":"matrix(o::PotentialTerm, method::FiniteDifferenceMethod)\n\nThe matrix for the potential energy V(r) is a diagonal matrix,\n\npmbV = \nleft(beginarrayccccccc\n  V(r_1)  0  0  ldots \n  0  V(r_2)  0  ldots \n  0  0  V(r_3)  ldots \n  vdots  vdots  vdots  ddots \nendarrayright)\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.optimize-Tuple{Hamiltonian, BasisSet}","page":"API reference","title":"TwoBody.optimize","text":"function optimize(hamiltonian::Hamiltonian, basisset::BasisSet; perturbation=Hamiltonian(), info=4, progress=true, optimizer=Optim.NelderMead(), options...)\n\nThis function minimizes the energy by changing the exponents of the basis functions using Optim.jl.\n\nfracpartial Epartial a_i = 0\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.optimize-Tuple{Hamiltonian, Basis}","page":"API reference","title":"TwoBody.optimize","text":"optimize(hamiltonian::Hamiltonian, basis::Basis; perturbation=Hamiltonian(), info=4, optimizer=Optim.NelderMead())\n\nThis a optimizer for 1-basis calculations. This function returns optimize(hamiltonian, BasisSet(basis); perturbation=perturbation, info=info, progress=progress, optimizer=optimizer, options...).\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.optimize-Tuple{Hamiltonian, GeometricBasisSet}","page":"API reference","title":"TwoBody.optimize","text":"optimize(hamiltonian::Hamiltonian, basisset::GeometricBasisSet; perturbation=Hamiltonian(), info=4, optimizer=Optim.NelderMead())\n\nThis function minimizes the energy by optimizing r_1 and r_n using Optim.jl.\n\nfracpartial Epartial r_1 = fracpartial Epartial r_n = 0\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.solve","page":"API reference","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, wavefunction::Function, method::FiniteDifferenceMethod, info=4, nₘₐₓ=4)\n\n\n\n\n\n","category":"function"},{"location":"API/#TwoBody.solve-Tuple{Hamiltonian, BasisSet}","page":"API reference","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, basisset::BasisSet)\n\nThis function returns the eigenvalues E  and eigenvectors pmbc for\n\npmbH pmbc = E pmbS pmbc\n\nThe Hamiltonian matrix is defined as H_ij = langle phi_i  hatH  phi_j rangle. The overlap matrix is defined as S_ij = langle phi_i  phi_j rangle.\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.solve-Tuple{Hamiltonian, Basis}","page":"API reference","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, basis::Basis; perturbation=Hamiltonian(), info=4)\n\nThis a solver for 1-basis calculations. This function returns solve(hamiltonian, BasisSet(basis); perturbation=perturbation, info=info).\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.solve-Tuple{Hamiltonian, FiniteDifferenceMethod}","page":"API reference","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, method::FiniteDifferenceMethod; perturbation=Hamiltonian(), info=4, nₘₐₓ=4)\n\nThis method solve the eigenvalue problem for the Hamiltonian discretized as a sparse matrix with finite difference approximation,\n\npmbH pmbpsi = E pmbpsi\n\nThe eigenvalue E is an approximation of the exact energy and the eigenvector pmbpsi is a vector of the approximated values of the exact wavefunction psi(r) on points of the grid,\n\npmbpsi\n=\nleft(beginarrayc\n  psi(r_1) \n  psi(r_2) \n  psi(r_3) \n  vdots \nendarrayright)\n\n\n\n\n\n","category":"method"},{"location":"API/#TwoBody.solve-Tuple{Hamiltonian, GeometricBasisSet}","page":"API reference","title":"TwoBody.solve","text":"solve(hamiltonian::Hamiltonian, basisset::GeometricBasisSet; perturbation=Hamiltonian(), info=4)\n\nThis function is a wrapper for solve(hamiltonian::Hamiltonian, basisset::BasisSet, ...).\n\n\n\n\n\n","category":"method"}]
}
